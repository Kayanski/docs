---
sidebar_position: 2
---


import IncentivesSetAssetIncentiveUrl from '@site/static/img//develop/contracts/incentives-set-asset-incentive.png';
import IncentivesBalanceChangeUrl from '@site/static/img//develop/contracts/incentives-balance-change.png';
import IncentivesClaimRewardsUrl from '@site/static/img//develop/contracts/incentives-claim-rewards.png';
import IncentivesUpdateConfigUrl from '@site/static/img//develop/contracts/incentives-update-config.png';



# incentives

Manage MARS incentives for depositors.

## Links

- **Contract address:** 
- **Testnet address:** `osmo1rkx9t4y72xxynl2dglnl3zrgpdynzjj2f0nyshckfu4u5s0zssjqcyduva`
- **Contract repo:** https://github.com/mars-protocol/outposts/tree/master/contracts/incentives
- **contract.rs:** https://github.com/mars-protocol/outposts/blob/master/contracts/incentives/src/contract.rs
- **incentives.rs (packages):** https://github.com/mars-protocol/outposts/blob/master/packages/outpost/src/incentives.rs
- **Tests:** https://github.com/mars-protocol/outposts/tree/master/contracts/incentives/tests
- **Audit:**

## InstantiateMsg

Instantiates the Incentives contract.

<CH.Section>
<CH.Code>

```json json
{
    "owner": "...", 
    "address_provider": "...",
    "mars_denom": "..."
}
```

```rust incentives.rs
#[cw_serde]
pub struct InstantiateMsg {
    pub owner: String,
    pub address_provider: String,
    pub mars_denom: String,
}
```

```rust contract.rs
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn instantiate(
    deps: DepsMut,
    _env: Env,
    _info: MessageInfo,
    msg: InstantiateMsg,
) -> StdResult<Response> {
    cw2::set_contract_version(deps.storage, CONTRACT_NAME, CONTRACT_VERSION)?;

    let config = Config {
        owner: deps.api.addr_validate(&msg.owner)?,
        address_provider: deps.api.addr_validate(&msg.address_provider)?,
        mars_denom: msg.mars_denom,
    };

    CONFIG.save(deps.storage, &config)?;

    Ok(Response::default())
}
```

```rust test
#[test]
fn test_proper_initialization() {
    let mut deps = mock_dependencies(&[]);

    let info = mock_info("sender", &[]);
    let msg = InstantiateMsg {
        owner: String::from("owner"),
        address_provider: String::from("address_provider"),
        mars_denom: String::from("umars"),
    };

    let res = instantiate(deps.as_mut(), mock_env(), info, msg).unwrap();
    let empty_vec: Vec<SubMsg> = vec![];
    assert_eq!(empty_vec, res.messages);

    let config = CONFIG.load(deps.as_ref().storage).unwrap();
    assert_eq!(config.owner, Addr::unchecked("owner"));
    assert_eq!(config.mars_denom, "umars".to_string());
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`owner`](focus://json#2)   | `String`        | Contract owner        |
| [`address_provider`](focus://json#3)   | `String`        | Address provider        |
| [`mars_denom`](focus://json#4)   | `String`        | Mars token denom        |

</CH.Section>

## ExecuteMsg

### `set_asset_incentive`

Set emission per second for an asset to its depositor at Red Bank.

<CH.Section>
<CH.Code>

```json json
{
    "set_asset_incentive": {
        "denom": "...", 
        "emission_per_second": 123
    }
}
```

```rust incentives.rs focus=1:6,19
#[cw_serde]
pub enum ExecuteMsg {
    SetAssetIncentive {
        denom: String,
        emission_per_second: Uint128,
    },
    BalanceChange {
        user_addr: Addr,
        denom: String,
        user_amount_scaled_before: Uint128,
        total_amount_scaled_before: Uint128,
    },
    ClaimRewards {},
    UpdateConfig {
        owner: Option<String>,
        address_provider: Option<String>,
        mars_denom: Option<String>,
    },
}
```

```rust contract.rs focus=1:12,33:34,36:92
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::SetAssetIncentive {
            denom,
            emission_per_second,
        } => execute_set_asset_incentive(deps, env, info, denom, emission_per_second),
        ExecuteMsg::BalanceChange {
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        } => execute_balance_change(
            deps,
            env,
            info,
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        ),
        ExecuteMsg::ClaimRewards {} => execute_claim_rewards(deps, env, info),
        ExecuteMsg::UpdateConfig {
            owner,
            address_provider,
            mars_denom,
        } => Ok(execute_update_config(deps, env, info, owner, address_provider, mars_denom)?),
    }
}

pub fn execute_set_asset_incentive(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    denom: String,
    emission_per_second: Uint128,
) -> Result<Response, ContractError> {
    // only owner can call this
    let config = CONFIG.load(deps.storage)?;
    let owner = config.owner;
    if info.sender != owner {
        return Err(MarsError::Unauthorized {}.into());
    }

    let red_bank_addr = address_provider::helpers::query_address(
        deps.as_ref(),
        &config.address_provider,
        MarsAddressType::RedBank,
    )?;

    let new_asset_incentive = match ASSET_INCENTIVES.may_load(deps.storage, &denom)? {
        Some(mut asset_incentive) => {
            let market: red_bank::Market = deps.querier.query_wasm_smart(
                &red_bank_addr,
                &red_bank::QueryMsg::Market {
                    denom: denom.clone(),
                },
            )?;

            // Update index up to now
            asset_incentive_update_index(
                &mut asset_incentive,
                market.collateral_total_scaled,
                env.block.time.seconds(),
            )?;

            // Set new emission
            asset_incentive.emission_per_second = emission_per_second;

            asset_incentive
        }
        None => AssetIncentive {
            emission_per_second,
            index: Decimal::zero(),
            last_updated: env.block.time.seconds(),
        },
    };

    ASSET_INCENTIVES.save(deps.storage, &denom, &new_asset_incentive)?;

    let response = Response::new().add_attributes(vec![
        attr("action", "outposts/incentives/set_asset_incentive"),
        attr("denom", denom),
        attr("emission_per_second", emission_per_second),
    ]);
    Ok(response)
}
```

```rust test
#[test]
fn test_only_owner_can_set_asset_incentive() {
    let mut deps = setup_test();

    let info = mock_info("sender", &[]);
    let msg = ExecuteMsg::SetAssetIncentive {
        denom: "uosmo".to_string(),
        emission_per_second: Uint128::new(100),
    };

    let res_error = execute(deps.as_mut(), mock_env(), info, msg).unwrap_err();
    assert_eq!(res_error, ContractError::Mars(MarsError::Unauthorized {}));
}

#[test]
fn test_set_new_asset_incentive() {
    let mut deps = setup_test();
    let denom = "uosmo";

    let info = mock_info("owner", &[]);
    let env = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(1_000_000),
        ..Default::default()
    });
    let msg = ExecuteMsg::SetAssetIncentive {
        denom: "uosmo".to_string(),
        emission_per_second: Uint128::new(100),
    };

    let res = execute(deps.as_mut(), env, info, msg).unwrap();
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/set_asset_incentive"),
            attr("denom", "uosmo"),
            attr("emission_per_second", "100"),
        ]
    );

    let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();

    assert_eq!(asset_incentive.emission_per_second, Uint128::new(100));
    assert_eq!(asset_incentive.index, Decimal::zero());
    assert_eq!(asset_incentive.last_updated, 1_000_000);
}

#[test]
fn test_set_existing_asset_incentive() {
    // setup
    let mut deps = setup_test();
    let denom = "uosmo";
    let total_collateral_scaled = Uint128::new(2_000_000);

    deps.querier.set_redbank_market(Market {
        denom: denom.to_string(),
        collateral_total_scaled: total_collateral_scaled,
        ..Default::default()
    });

    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            denom,
            &AssetIncentive {
                emission_per_second: Uint128::new(100),
                index: Decimal::from_ratio(1_u128, 2_u128),
                last_updated: 500_000,
            },
        )
        .unwrap();

    // execute msg
    let info = mock_info("owner", &[]);
    let env = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(1_000_000),
        ..Default::default()
    });
    let msg = ExecuteMsg::SetAssetIncentive {
        denom: "uosmo".to_string(),
        emission_per_second: Uint128::new(200),
    };

    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    // tests
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/set_asset_incentive"),
            attr("denom", "uosmo"),
            attr("emission_per_second", "200"),
        ]
    );

    let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();

    let expected_index = asset_incentive_compute_index(
        Decimal::from_ratio(1_u128, 2_u128),
        Uint128::new(100),
        total_collateral_scaled,
        500_000,
        1_000_000,
    )
    .unwrap();

    assert_eq!(asset_incentive.emission_per_second, Uint128::new(200));
    assert_eq!(asset_incentive.index, expected_index);
    assert_eq!(asset_incentive.last_updated, 1_000_000);
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`        | Asset denom associated with the incentives       |
| [`emission_per_second`](focus://json#4)   | `Uint128`        | How many MARS will be assigned per second to be distributed among all Red Bank depositors        |

</CH.Section>

<img src={IncentivesSetAssetIncentiveUrl} />


### `balance_change`

Handle balance change updating user and asset rewards. Sent from an external contract, triggered on user balance changes. Will return an empty response if no incentive is applied for the asset

<CH.Section>
<CH.Code>

```json json
{
    "balance_change": {
        "user_addr": "mars...", 
        "denom": "...", 
        "user_amount_scaled_before": 123, 
        "total_amount_scaled_before": 123
    }
}
```

```rust incentives.rs focus=1:2,7:12,19
#[cw_serde]
pub enum ExecuteMsg {
    SetAssetIncentive {
        denom: String,
        emission_per_second: Uint128,
    },
    BalanceChange {
        user_addr: Addr,
        denom: String,
        user_amount_scaled_before: Uint128,
        total_amount_scaled_before: Uint128,
    },
    ClaimRewards {},
    UpdateConfig {
        owner: Option<String>,
        address_provider: Option<String>,
        mars_denom: Option<String>,
    },
}
```

```rust contract.rs focus=1:8,13:26,33:34,36:110
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::SetAssetIncentive {
            denom,
            emission_per_second,
        } => execute_set_asset_incentive(deps, env, info, denom, emission_per_second),
        ExecuteMsg::BalanceChange {
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        } => execute_balance_change(
            deps,
            env,
            info,
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        ),
        ExecuteMsg::ClaimRewards {} => execute_claim_rewards(deps, env, info),
        ExecuteMsg::UpdateConfig {
            owner,
            address_provider,
            mars_denom,
        } => Ok(execute_update_config(deps, env, info, owner, address_provider, mars_denom)?),
    }
}

pub fn execute_balance_change(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    user_addr: Addr,
    denom: String,
    user_amount_scaled_before: Uint128,
    total_amount_scaled_before: Uint128,
) -> Result<Response, ContractError> {
    // this method can only be invoked by the Red Bank contract
    let red_bank_addr = query_red_bank_address(deps.as_ref())?;
    if info.sender != red_bank_addr {
        return Err(MarsError::Unauthorized {}.into());
    }

    let mut asset_incentive = match ASSET_INCENTIVES.may_load(deps.storage, &denom)? {
        // If there are no incentives,
        // an empty successful response is returned as the
        // success of the call is needed for the call that triggered the change to
        // succeed and be persisted to state.
        None => return Ok(Response::default()),

        Some(ai) => ai,
    };

    asset_incentive_update_index(
        &mut asset_incentive,
        total_amount_scaled_before,
        env.block.time.seconds(),
    )?;
    ASSET_INCENTIVES.save(deps.storage, &denom, &asset_incentive)?;

    // Check if user has accumulated uncomputed rewards (which means index is not up to date)
    let user_asset_index_key = USER_ASSET_INDICES.key((&user_addr, &denom));

    let user_asset_index =
        user_asset_index_key.may_load(deps.storage)?.unwrap_or_else(Decimal::zero);

    let mut accrued_rewards = Uint128::zero();

    if user_asset_index != asset_incentive.index {
        // Compute user accrued rewards and update state
        accrued_rewards = user_compute_accrued_rewards(
            user_amount_scaled_before,
            user_asset_index,
            asset_incentive.index,
        )?;

        // Store user accrued rewards as unclaimed
        if !accrued_rewards.is_zero() {
            USER_UNCLAIMED_REWARDS.update(
                deps.storage,
                &user_addr,
                |ur: Option<Uint128>| -> StdResult<Uint128> {
                    match ur {
                        Some(unclaimed_rewards) => Ok(unclaimed_rewards + accrued_rewards),
                        None => Ok(accrued_rewards),
                    }
                },
            )?;
        }

        user_asset_index_key.save(deps.storage, &asset_incentive.index)?;
    }

    let response = Response::new().add_attributes(vec![
        attr("action", "outposts/incentives/balance_change"),
        attr("denom", denom),
        attr("user", user_addr),
        attr("rewards_accrued", accrued_rewards),
        attr("asset_index", asset_incentive.index.to_string()),
    ]);

    Ok(response)
}
```

```rust test
#[test]
fn test_balance_change_unauthorized() {
    let mut deps = setup_test();

    // the `balance_change` method can only be invoked by Red Bank contract
    let err = execute(
        deps.as_mut(),
        mock_env(),
        mock_info("jake", &[]), // not Red Bank
        ExecuteMsg::BalanceChange {
            user_addr: Addr::unchecked("user"),
            denom: "uosmo".to_string(),
            user_amount_scaled_before: Uint128::new(100000),
            total_amount_scaled_before: Uint128::new(100000),
        },
    )
    .unwrap_err();
    assert_eq!(err, MarsError::Unauthorized {}.into());
}

#[test]
fn test_execute_balance_change_noops() {
    let mut deps = setup_test();

    // non existing incentive returns a no op
    let info = mock_info("red_bank", &[]);
    let msg = ExecuteMsg::BalanceChange {
        user_addr: Addr::unchecked("user"),
        denom: "uosmo".to_string(),
        user_amount_scaled_before: Uint128::new(100000),
        total_amount_scaled_before: Uint128::new(100000),
    };

    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();
    assert_eq!(res, Response::default())
}

#[test]
fn test_balance_change_zero_emission() {
    let mut deps = setup_test();
    let denom = "uosmo";
    let user_addr = Addr::unchecked("user");
    let asset_incentive_index = Decimal::from_ratio(1_u128, 2_u128);

    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            denom,
            &AssetIncentive {
                emission_per_second: Uint128::zero(),
                index: asset_incentive_index,
                last_updated: 500_000,
            },
        )
        .unwrap();

    let info = mock_info("red_bank", &[]);
    let env = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(600_000),
        ..Default::default()
    });
    let msg = ExecuteMsg::BalanceChange {
        user_addr: Addr::unchecked("user"),
        denom: "uosmo".to_string(),
        user_amount_scaled_before: Uint128::new(100_000),
        total_amount_scaled_before: Uint128::new(100_000),
    };

    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let expected_accrued_rewards =
        user_compute_accrued_rewards(Uint128::new(100_000), Decimal::zero(), asset_incentive_index)
            .unwrap();

    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/balance_change"),
            attr("denom", denom),
            attr("user", "user"),
            attr("rewards_accrued", expected_accrued_rewards),
            attr("asset_index", asset_incentive_index.to_string()),
        ]
    );

    // asset incentive index stays the same
    let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();
    assert_eq!(asset_incentive.index, asset_incentive_index);
    assert_eq!(asset_incentive.last_updated, 600_000);

    // user index is set to asset's index
    let user_asset_index =
        USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, denom)).unwrap();
    assert_eq!(user_asset_index, asset_incentive_index);

    // rewards get updated
    let user_unclaimed_rewards =
        USER_UNCLAIMED_REWARDS.load(deps.as_ref().storage, &user_addr).unwrap();
    assert_eq!(user_unclaimed_rewards, expected_accrued_rewards)
}

#[test]
fn test_balance_change_user_with_zero_balance() {
    let mut deps = setup_test();
    let denom = "uosmo";
    let user_addr = Addr::unchecked("user");

    let start_index = Decimal::from_ratio(1_u128, 2_u128);
    let emission_per_second = Uint128::new(100);
    let total_supply = Uint128::new(100_000);
    let time_last_updated = 500_000_u64;
    let time_contract_call = 600_000_u64;

    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            denom,
            &AssetIncentive {
                emission_per_second,
                index: start_index,
                last_updated: time_last_updated,
            },
        )
        .unwrap();

    let info = mock_info("red_bank", &[]);
    let env = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(time_contract_call),
        ..Default::default()
    });
    let msg = ExecuteMsg::BalanceChange {
        user_addr: user_addr.clone(),
        denom: "uosmo".to_string(),
        user_amount_scaled_before: Uint128::zero(),
        total_amount_scaled_before: total_supply,
    };

    let res = execute(deps.as_mut(), env, info, msg).unwrap();

    let expected_index = asset_incentive_compute_index(
        start_index,
        emission_per_second,
        total_supply,
        time_last_updated,
        time_contract_call,
    )
    .unwrap();

    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/balance_change"),
            attr("denom", denom),
            attr("user", "user"),
            attr("rewards_accrued", "0"),
            attr("asset_index", expected_index.to_string()),
        ]
    );

    // asset incentive gets updated
    let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();
    assert_eq!(asset_incentive.index, expected_index);
    assert_eq!(asset_incentive.last_updated, time_contract_call);

    // user index is set to asset's index
    let user_asset_index =
        USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, denom)).unwrap();
    assert_eq!(user_asset_index, expected_index);

    // no new rewards
    let user_unclaimed_rewards =
        USER_UNCLAIMED_REWARDS.may_load(deps.as_ref().storage, &user_addr).unwrap();
    assert_eq!(user_unclaimed_rewards, None)
}

#[test]
fn test_with_zero_previous_balance_and_asset_with_zero_index_accumulates_rewards() {
    let mut deps = setup_test();
    let denom = "uosmo";
    let user_addr = Addr::unchecked("user");

    let start_index = Decimal::zero();
    let emission_per_second = Uint128::new(100);
    let time_last_updated = 500_000_u64;
    let time_contract_call = 600_000_u64;

    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            denom,
            &AssetIncentive {
                emission_per_second,
                index: start_index,
                last_updated: time_last_updated,
            },
        )
        .unwrap();

    {
        let info = mock_info("red_bank", &[]);
        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });
        let msg = ExecuteMsg::BalanceChange {
            user_addr: user_addr.clone(),
            denom: "uosmo".to_string(),
            user_amount_scaled_before: Uint128::zero(),
            total_amount_scaled_before: Uint128::zero(),
        };
        // Execute balance changed, this is the first mint of the asset, so previous total
        // supply and user balance is 0
        execute(deps.as_mut(), env, info, msg).unwrap();
    }

    {
        // Some time passes and we query the user rewards, expected value should not be 0
        let user_balance = Uint128::new(100_000);
        let total_supply = Uint128::new(100_000);
        deps.querier.set_redbank_market(Market {
            denom: denom.to_string(),
            collateral_total_scaled: total_supply,
            ..Default::default()
        });
        deps.querier.set_red_bank_user_collateral(
            &user_addr,
            UserCollateralResponse {
                denom: denom.to_string(),
                amount_scaled: user_balance,
                amount: Uint128::zero(), // doesn't matter for this test
                enabled: true,
            },
        );
        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call + 1000),
            ..Default::default()
        });
        let rewards_query =
            query_user_unclaimed_rewards(deps.as_ref(), env, String::from("user")).unwrap();
        assert_eq!(Uint128::new(1000).checked_mul(emission_per_second).unwrap(), rewards_query);
    }
}

#[test]
fn test_set_new_asset_incentive_user_non_zero_balance() {
    let mut deps = setup_test();
    let user_addr = Addr::unchecked("user");

    // set collateral shares for user
    let denom = "uosmo";
    let total_supply = Uint128::new(100_000);
    let user_balance = Uint128::new(10_000);

    deps.querier.set_redbank_market(Market {
        denom: denom.to_string(),
        collateral_total_scaled: total_supply,
        ..Default::default()
    });
    deps.querier.set_red_bank_user_collateral(
        &user_addr,
        UserCollateralResponse {
            denom: denom.to_string(),
            amount_scaled: user_balance,
            amount: Uint128::zero(), // doesn't matter for this test
            enabled: true,
        },
    );

    // set asset incentive
    {
        let time_last_updated = 500_000_u64;
        let emission_per_second = Uint128::new(100);
        let asset_incentive_index = Decimal::zero();

        ASSET_INCENTIVES
            .save(
                deps.as_mut().storage,
                denom,
                &AssetIncentive {
                    emission_per_second,
                    index: asset_incentive_index,
                    last_updated: time_last_updated,
                },
            )
            .unwrap();
    }

    // first query
    {
        let time_contract_call = 600_000_u64;

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });

        let unclaimed_rewards =
            query_user_unclaimed_rewards(deps.as_ref(), env, "user".to_string()).unwrap();
        // 100_000 s * 100 MARS/s * 1/10th of total deposit
        let expected_unclaimed_rewards = Uint128::new(1_000_000);
        assert_eq!(unclaimed_rewards, expected_unclaimed_rewards);
    }

    // increase user user deposit amount
    {
        let time_contract_call = 700_000_u64;
        let user_balance = Uint128::new(25_000);

        deps.querier.set_red_bank_user_collateral(
            &user_addr,
            UserCollateralResponse {
                denom: denom.to_string(),
                amount_scaled: user_balance,
                amount: Uint128::zero(), // doesn't matter for this test
                enabled: true,
            },
        );

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });

        let info = mock_info("red_bank", &[]);

        execute_balance_change(
            deps.as_mut(),
            env,
            info,
            user_addr,
            denom.to_string(),
            Uint128::new(10_000),
            total_supply,
        )
        .unwrap();
    }

    // second query
    {
        let time_contract_call = 800_000_u64;

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });

        let unclaimed_rewards =
            query_user_unclaimed_rewards(deps.as_ref(), env, "user".to_string()).unwrap();
        let expected_unclaimed_rewards = Uint128::new(
            // 200_000 s * 100 MARS/s * 1/10th of total deposit +
            2_000_000 +
                // 100_000 s * 100 MARS/s * 1/4 of total deposit
                2_500_000,
        );
        assert_eq!(unclaimed_rewards, expected_unclaimed_rewards);
    }
}

#[test]
fn test_balance_change_user_non_zero_balance() {
    let mut deps = setup_test();
    let denom = "uosmo";
    let user_addr = Addr::unchecked("user");

    let emission_per_second = Uint128::new(100);
    let total_supply = Uint128::new(100_000);

    let mut expected_asset_incentive_index = Decimal::from_ratio(1_u128, 2_u128);
    let mut expected_time_last_updated = 500_000_u64;
    let mut expected_accumulated_rewards = Uint128::zero();

    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            denom,
            &AssetIncentive {
                emission_per_second,
                index: expected_asset_incentive_index,
                last_updated: expected_time_last_updated,
            },
        )
        .unwrap();

    let info = mock_info("red_bank", &[]);

    // first call no previous rewards
    {
        let time_contract_call = 600_000_u64;
        let user_balance = Uint128::new(10_000);

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });
        let msg = ExecuteMsg::BalanceChange {
            user_addr: user_addr.clone(),
            denom: "uosmo".to_string(),
            user_amount_scaled_before: user_balance,
            total_amount_scaled_before: total_supply,
        };
        let res = execute(deps.as_mut(), env, info.clone(), msg).unwrap();

        expected_asset_incentive_index = asset_incentive_compute_index(
            expected_asset_incentive_index,
            emission_per_second,
            total_supply,
            expected_time_last_updated,
            time_contract_call,
        )
        .unwrap();

        let expected_accrued_rewards = user_compute_accrued_rewards(
            user_balance,
            Decimal::zero(),
            expected_asset_incentive_index,
        )
        .unwrap();
        assert_eq!(
            res.attributes,
            vec![
                attr("action", "outposts/incentives/balance_change"),
                attr("denom", denom),
                attr("user", "user"),
                attr("rewards_accrued", expected_accrued_rewards),
                attr("asset_index", expected_asset_incentive_index.to_string()),
            ]
        );

        // asset incentive gets updated
        expected_time_last_updated = time_contract_call;

        let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();
        assert_eq!(asset_incentive.index, expected_asset_incentive_index);
        assert_eq!(asset_incentive.last_updated, expected_time_last_updated);

        // user index is set to asset's index
        let user_asset_index =
            USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, denom)).unwrap();
        assert_eq!(user_asset_index, expected_asset_incentive_index);

        // user gets new rewards
        let user_unclaimed_rewards =
            USER_UNCLAIMED_REWARDS.load(deps.as_ref().storage, &user_addr).unwrap();
        expected_accumulated_rewards += expected_accrued_rewards;
        assert_eq!(user_unclaimed_rewards, expected_accumulated_rewards)
    }

    // Second call accumulates new rewards
    {
        let time_contract_call = 700_000_u64;
        let user_balance = Uint128::new(20_000);

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });
        let msg = ExecuteMsg::BalanceChange {
            user_addr: user_addr.clone(),
            denom: "uosmo".to_string(),
            user_amount_scaled_before: user_balance,
            total_amount_scaled_before: total_supply,
        };
        let res = execute(deps.as_mut(), env, info.clone(), msg).unwrap();

        let previous_user_index = expected_asset_incentive_index;
        expected_asset_incentive_index = asset_incentive_compute_index(
            expected_asset_incentive_index,
            emission_per_second,
            total_supply,
            expected_time_last_updated,
            time_contract_call,
        )
        .unwrap();

        let expected_accrued_rewards = user_compute_accrued_rewards(
            user_balance,
            previous_user_index,
            expected_asset_incentive_index,
        )
        .unwrap();
        assert_eq!(
            res.attributes,
            vec![
                attr("action", "outposts/incentives/balance_change"),
                attr("denom", denom),
                attr("user", "user"),
                attr("rewards_accrued", expected_accrued_rewards),
                attr("asset_index", expected_asset_incentive_index.to_string()),
            ]
        );

        // asset incentive gets updated
        expected_time_last_updated = time_contract_call;

        let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();
        assert_eq!(asset_incentive.index, expected_asset_incentive_index);
        assert_eq!(asset_incentive.last_updated, expected_time_last_updated);

        // user index is set to asset's index
        let user_asset_index =
            USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, denom)).unwrap();
        assert_eq!(user_asset_index, expected_asset_incentive_index);

        // user gets new rewards
        let user_unclaimed_rewards =
            USER_UNCLAIMED_REWARDS.load(deps.as_ref().storage, &user_addr).unwrap();
        expected_accumulated_rewards += expected_accrued_rewards;
        assert_eq!(user_unclaimed_rewards, expected_accumulated_rewards)
    }

    // Third call same block does not change anything
    {
        let time_contract_call = 700_000_u64;
        let user_balance = Uint128::new(20_000);

        let env = mars_testing::mock_env(MockEnvParams {
            block_time: Timestamp::from_seconds(time_contract_call),
            ..Default::default()
        });
        let msg = ExecuteMsg::BalanceChange {
            user_addr: user_addr.clone(),
            denom: "uosmo".to_string(),
            user_amount_scaled_before: user_balance,
            total_amount_scaled_before: total_supply,
        };
        let res = execute(deps.as_mut(), env, info, msg).unwrap();

        assert_eq!(
            res.attributes,
            vec![
                attr("action", "outposts/incentives/balance_change"),
                attr("denom", denom),
                attr("user", "user"),
                attr("rewards_accrued", "0"),
                attr("asset_index", expected_asset_incentive_index.to_string()),
            ]
        );

        // asset incentive is still the same
        let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, denom).unwrap();
        assert_eq!(asset_incentive.index, expected_asset_incentive_index);
        assert_eq!(asset_incentive.last_updated, expected_time_last_updated);

        // user index is still the same
        let user_asset_index =
            USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, denom)).unwrap();
        assert_eq!(user_asset_index, expected_asset_incentive_index);

        // user gets no new rewards
        let user_unclaimed_rewards =
            USER_UNCLAIMED_REWARDS.load(deps.as_ref().storage, &user_addr).unwrap();
        assert_eq!(user_unclaimed_rewards, expected_accumulated_rewards)
    }
}
```

</CH.Code>


| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user_addr`](focus://json#3)   | `Addr`        | User address. Address is trusted as it must be validated by the Red Bank contract before calling this method        |
| [`denom`](focus://json#4)   | `String`        | Denom of the asset of which deposited balance is changed        |
| [`user_amount_scaled_before`](focus://json#5)   | `Uint128`        | The user's scaled collateral amount up to the instant before the change        |
| [`total_amount_scaled_before`](focus://json#6)   | `Uint128`        | The market's total scaled collateral amount up to the instant before the change        |

</CH.Section>

<img src={IncentivesBalanceChangeUrl} />


### `claim_rewards`

Claim rewards. MARS rewards accrued by the user will be staked before being sent.

<CH.Section>
<CH.Code>

```json json
{
    "claim_rewards": {}
}
```

```rust incentives.rs focus=1:2,13,19
#[cw_serde]
pub enum ExecuteMsg {
    SetAssetIncentive {
        denom: String,
        emission_per_second: Uint128,
    },
    BalanceChange {
        user_addr: Addr,
        denom: String,
        user_amount_scaled_before: Uint128,
        total_amount_scaled_before: Uint128,
    },
    ClaimRewards {},
    UpdateConfig {
        owner: Option<String>,
        address_provider: Option<String>,
        mars_denom: Option<String>,
    },
}
```

```rust contract.rs focus=1:8,27,33:34,36:85
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::SetAssetIncentive {
            denom,
            emission_per_second,
        } => execute_set_asset_incentive(deps, env, info, denom, emission_per_second),
        ExecuteMsg::BalanceChange {
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        } => execute_balance_change(
            deps,
            env,
            info,
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        ),
        ExecuteMsg::ClaimRewards {} => execute_claim_rewards(deps, env, info),
        ExecuteMsg::UpdateConfig {
            owner,
            address_provider,
            mars_denom,
        } => Ok(execute_update_config(deps, env, info, owner, address_provider, mars_denom)?),
    }
}

pub fn execute_claim_rewards(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
) -> Result<Response, ContractError> {
    let red_bank_addr = query_red_bank_address(deps.as_ref())?;
    let user_addr = info.sender;
    let (total_unclaimed_rewards, user_asset_incentive_statuses_to_update) =
        compute_user_unclaimed_rewards(deps.as_ref(), &env.block, &red_bank_addr, &user_addr)?;

    // Commit updated asset_incentives and user indexes
    for user_asset_incentive_status in user_asset_incentive_statuses_to_update {
        let asset_incentive_updated = user_asset_incentive_status.asset_incentive_updated;

        ASSET_INCENTIVES.save(
            deps.storage,
            &user_asset_incentive_status.denom,
            &asset_incentive_updated,
        )?;

        if asset_incentive_updated.index != user_asset_incentive_status.user_index_current {
            USER_ASSET_INDICES.save(
                deps.storage,
                (&user_addr, &user_asset_incentive_status.denom),
                &asset_incentive_updated.index,
            )?
        }
    }

    // clear unclaimed rewards
    USER_UNCLAIMED_REWARDS.save(deps.storage, &user_addr, &Uint128::zero())?;

    let mut response = Response::new();
    if !total_unclaimed_rewards.is_zero() {
        let config = CONFIG.load(deps.storage)?;
        // Build message to send mars to the user
        response = response.add_message(CosmosMsg::Bank(BankMsg::Send {
            to_address: user_addr.to_string(),
            amount: coins(total_unclaimed_rewards.u128(), config.mars_denom),
        }));
    };

    response = response.add_attributes(vec![
        attr("action", "outposts/incentives/claim_rewards"),
        attr("user", user_addr),
        attr("mars_rewards", total_unclaimed_rewards),
    ]);

    Ok(response)
}
```

```rust test
#[test]
fn test_execute_claim_rewards() {
    // SETUP
    let mut deps = setup_test();
    let user_addr = Addr::unchecked("user");

    let previous_unclaimed_rewards = Uint128::new(50_000);
    let asset_total_supply = Uint128::new(100_000);
    let asset_user_balance = Uint128::new(10_000);
    let zero_total_supply = Uint128::new(200_000);
    let zero_user_balance = Uint128::new(10_000);
    let no_user_total_supply = Uint128::new(100_000);
    let no_user_user_balance = Uint128::zero();
    let time_start = 500_000_u64;
    let time_contract_call = 600_000_u64;

    // addresses
    // denom of an asset with ongoing rewards
    let asset_denom = "asset";
    // denom of an asset with no pending rewards but with user index (so it had active incentives
    // at some point)
    let zero_denom = "zero";
    // denom of an asset where the user never had a balance during an active
    // incentive -> hence no associated index
    let no_user_denom = "no_user";

    deps.querier.set_redbank_market(Market {
        denom: asset_denom.to_string(),
        collateral_total_scaled: asset_total_supply,
        ..Default::default()
    });
    deps.querier.set_redbank_market(Market {
        denom: zero_denom.to_string(),
        collateral_total_scaled: zero_total_supply,
        ..Default::default()
    });
    deps.querier.set_redbank_market(Market {
        denom: no_user_denom.to_string(),
        collateral_total_scaled: no_user_total_supply,
        ..Default::default()
    });
    deps.querier.set_red_bank_user_collateral(
        &user_addr,
        UserCollateralResponse {
            denom: asset_denom.to_string(),
            amount_scaled: asset_user_balance,
            amount: Uint128::zero(), // doesn't matter for this test
            enabled: true,
        },
    );
    deps.querier.set_red_bank_user_collateral(
        &user_addr,
        UserCollateralResponse {
            denom: zero_denom.to_string(),
            amount_scaled: zero_user_balance,
            amount: Uint128::zero(), // doesn't matter for this test
            enabled: true,
        },
    );
    deps.querier.set_red_bank_user_collateral(
        &user_addr,
        UserCollateralResponse {
            denom: no_user_denom.to_string(),
            amount_scaled: no_user_user_balance,
            amount: Uint128::zero(), // doesn't matter for this test
            enabled: true,
        },
    );

    // incentives
    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            asset_denom,
            &AssetIncentive {
                emission_per_second: Uint128::new(100),
                index: Decimal::one(),
                last_updated: time_start,
            },
        )
        .unwrap();
    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            zero_denom,
            &AssetIncentive {
                emission_per_second: Uint128::zero(),
                index: Decimal::one(),
                last_updated: time_start,
            },
        )
        .unwrap();
    ASSET_INCENTIVES
        .save(
            deps.as_mut().storage,
            no_user_denom,
            &AssetIncentive {
                emission_per_second: Uint128::new(200),
                index: Decimal::one(),
                last_updated: time_start,
            },
        )
        .unwrap();

    // user indices
    USER_ASSET_INDICES
        .save(deps.as_mut().storage, (&user_addr, asset_denom), &Decimal::one())
        .unwrap();

    USER_ASSET_INDICES
        .save(deps.as_mut().storage, (&user_addr, zero_denom), &Decimal::from_ratio(1_u128, 2_u128))
        .unwrap();

    // unclaimed_rewards
    USER_UNCLAIMED_REWARDS
        .save(deps.as_mut().storage, &user_addr, &previous_unclaimed_rewards)
        .unwrap();

    let expected_asset_incentive_index = asset_incentive_compute_index(
        Decimal::one(),
        Uint128::new(100),
        asset_total_supply,
        time_start,
        time_contract_call,
    )
    .unwrap();

    let expected_asset_accrued_rewards = user_compute_accrued_rewards(
        asset_user_balance,
        Decimal::one(),
        expected_asset_incentive_index,
    )
    .unwrap();

    let expected_zero_accrued_rewards = user_compute_accrued_rewards(
        zero_user_balance,
        Decimal::from_ratio(1_u128, 2_u128),
        Decimal::one(),
    )
    .unwrap();

    let expected_accrued_rewards =
        previous_unclaimed_rewards + expected_asset_accrued_rewards + expected_zero_accrued_rewards;

    // MSG
    let info = mock_info("user", &[]);
    let env = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(time_contract_call),
        ..Default::default()
    });
    let msg = ExecuteMsg::ClaimRewards {};

    // query a bit before gives less rewards
    let env_before = mars_testing::mock_env(MockEnvParams {
        block_time: Timestamp::from_seconds(time_contract_call - 10_000),
        ..Default::default()
    });
    let rewards_query_before =
        query_user_unclaimed_rewards(deps.as_ref(), env_before, String::from("user")).unwrap();
    assert!(rewards_query_before < expected_accrued_rewards);

    // query before execution gives expected rewards
    let rewards_query =
        query_user_unclaimed_rewards(deps.as_ref(), env.clone(), String::from("user")).unwrap();
    assert_eq!(rewards_query, expected_accrued_rewards);

    let res = execute(deps.as_mut(), env.clone(), info, msg).unwrap();

    // query after execution gives 0 rewards
    let rewards_query_after =
        query_user_unclaimed_rewards(deps.as_ref(), env, String::from("user")).unwrap();
    assert_eq!(rewards_query_after, Uint128::zero());

    // ASSERT

    assert_eq!(
        res.messages,
        vec![SubMsg::new(CosmosMsg::Bank(BankMsg::Send {
            to_address: user_addr.to_string(),
            amount: coins(expected_accrued_rewards.u128(), "umars".to_string())
        }))]
    );

    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/claim_rewards"),
            attr("user", "user"),
            attr("mars_rewards", expected_accrued_rewards),
        ]
    );

    // asset and zero incentives get updated, no_user does not
    let asset_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, asset_denom).unwrap();
    assert_eq!(asset_incentive.index, expected_asset_incentive_index);
    assert_eq!(asset_incentive.last_updated, time_contract_call);

    let zero_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, zero_denom).unwrap();
    assert_eq!(zero_incentive.index, Decimal::one());
    assert_eq!(zero_incentive.last_updated, time_contract_call);

    let no_user_incentive = ASSET_INCENTIVES.load(deps.as_ref().storage, no_user_denom).unwrap();
    assert_eq!(no_user_incentive.index, Decimal::one());
    assert_eq!(no_user_incentive.last_updated, time_start);

    // user's asset and zero indices are updated
    let user_asset_index =
        USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, asset_denom)).unwrap();
    assert_eq!(user_asset_index, expected_asset_incentive_index);

    let user_zero_index =
        USER_ASSET_INDICES.load(deps.as_ref().storage, (&user_addr, zero_denom)).unwrap();
    assert_eq!(user_zero_index, Decimal::one());

    // user's no_user does not get updated
    let user_no_user_index =
        USER_ASSET_INDICES.may_load(deps.as_ref().storage, (&user_addr, no_user_denom)).unwrap();
    assert_eq!(user_no_user_index, None);

    // user rewards are cleared
    let user_unclaimed_rewards =
        USER_UNCLAIMED_REWARDS.load(deps.as_ref().storage, &user_addr).unwrap();
    assert_eq!(user_unclaimed_rewards, Uint128::zero())
}

#[test]
fn test_claim_zero_rewards() {
    // SETUP
    let mut deps = setup_test();

    let info = mock_info("user", &[]);
    let msg = ExecuteMsg::ClaimRewards {};

    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();
    assert_eq!(res.messages.len(), 0);
    assert_eq!(
        res.attributes,
        vec![
            attr("action", "outposts/incentives/claim_rewards"),
            attr("user", "user"),
            attr("mars_rewards", "0"),
        ]
    );
}

#[test]
fn test_asset_incentive_compute_index() {
    assert_eq!(
        asset_incentive_compute_index(
            Decimal::zero(),
            Uint128::new(100),
            Uint128::new(200_000),
            1000,
            10
        ),
        Err(StdError::overflow(OverflowError::new(OverflowOperation::Sub, 1000, 10)))
    );

    assert_eq!(
        asset_incentive_compute_index(
            Decimal::zero(),
            Uint128::new(100),
            Uint128::new(200_000),
            0,
            1000
        )
        .unwrap(),
        Decimal::from_ratio(1_u128, 2_u128)
    );
    assert_eq!(
        asset_incentive_compute_index(
            Decimal::from_ratio(1_u128, 2_u128),
            Uint128::new(2000),
            Uint128::new(5_000_000),
            20_000,
            30_000
        )
        .unwrap(),
        Decimal::from_ratio(9_u128, 2_u128)
    );
}

#[test]
fn test_user_compute_accrued_rewards() {
    assert_eq!(
        user_compute_accrued_rewards(
            Uint128::zero(),
            Decimal::one(),
            Decimal::from_ratio(2_u128, 1_u128)
        )
        .unwrap(),
        Uint128::zero()
    );

    assert_eq!(
        user_compute_accrued_rewards(
            Uint128::new(100),
            Decimal::zero(),
            Decimal::from_ratio(2_u128, 1_u128)
        )
        .unwrap(),
        Uint128::new(200)
    );
    assert_eq!(
        user_compute_accrued_rewards(
            Uint128::new(100),
            Decimal::one(),
            Decimal::from_ratio(2_u128, 1_u128)
        )
        .unwrap(),
        Uint128::new(100)
    );
}
```

</CH.Code>
</CH.Section>

<img src={IncentivesClaimRewardsUrl} />


### `update_config`

Update contract config (only callable by owner).

<CH.Section>
<CH.Code>

```json json
{
    "update_config": {
        "owner": "...", 
        "address_provider": "...",
        "mars_denom": "..."
    }
}
```

```rust incentives.rs focus=1:2,14:18,19
#[cw_serde]
pub enum ExecuteMsg {
    SetAssetIncentive {
        denom: String,
        emission_per_second: Uint128,
    },
    BalanceChange {
        user_addr: Addr,
        denom: String,
        user_amount_scaled_before: Uint128,
        total_amount_scaled_before: Uint128,
    },
    ClaimRewards {},
    UpdateConfig {
        owner: Option<String>,
        address_provider: Option<String>,
        mars_denom: Option<String>,
    },
}
```

```rust contract.rs focus=1:8,28:34,36:60
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: ExecuteMsg,
) -> Result<Response, ContractError> {
    match msg {
        ExecuteMsg::SetAssetIncentive {
            denom,
            emission_per_second,
        } => execute_set_asset_incentive(deps, env, info, denom, emission_per_second),
        ExecuteMsg::BalanceChange {
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        } => execute_balance_change(
            deps,
            env,
            info,
            user_addr,
            denom,
            user_amount_scaled_before,
            total_amount_scaled_before,
        ),
        ExecuteMsg::ClaimRewards {} => execute_claim_rewards(deps, env, info),
        ExecuteMsg::UpdateConfig {
            owner,
            address_provider,
            mars_denom,
        } => Ok(execute_update_config(deps, env, info, owner, address_provider, mars_denom)?),
    }
}

pub fn execute_update_config(
    deps: DepsMut,
    _env: Env,
    info: MessageInfo,
    owner: Option<String>,
    address_provider: Option<String>,
    mars_denom: Option<String>,
) -> Result<Response, MarsError> {
    let mut config = CONFIG.load(deps.storage)?;

    if info.sender != config.owner {
        return Err(MarsError::Unauthorized {});
    };

    config.owner = option_string_to_addr(deps.api, owner, config.owner)?;
    config.address_provider =
        option_string_to_addr(deps.api, address_provider, config.address_provider)?;
    config.mars_denom = mars_denom.unwrap_or(config.mars_denom);

    CONFIG.save(deps.storage, &config)?;

    let response = Response::new().add_attribute("action", "outposts/incentives/update_config");

    Ok(response)
}
```

```rust test
#[test]
fn test_update_config() {
    let mut deps = setup_test();

    // *
    // non owner is not authorized
    // *
    let msg = ExecuteMsg::UpdateConfig {
        owner: None,
        address_provider: None,
        mars_denom: None,
    };
    let info = mock_info("somebody", &[]);
    let error_res = execute(deps.as_mut(), mock_env(), info, msg).unwrap_err();
    assert_eq!(error_res, ContractError::Mars(MarsError::Unauthorized {}));

    // *
    // update config with new params
    // *
    let msg = ExecuteMsg::UpdateConfig {
        owner: Some(String::from("new_owner")),
        address_provider: None,
        mars_denom: None,
    };
    let info = mock_info("owner", &[]);

    let res = execute(deps.as_mut(), mock_env(), info, msg).unwrap();
    assert_eq!(0, res.messages.len());

    // Read config from state
    let new_config = CONFIG.load(deps.as_ref().storage).unwrap();
    assert_eq!(new_config.owner, Addr::unchecked("new_owner"));
    assert_eq!(new_config.mars_denom, "umars".to_string());
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`owner`](focus://json#3)   | `Option<String>`        | Contract owner        |
| [`address_provider`](focus://json#4)   | `Option<String>`        | Address provider        |
| [`mars_denom`](focus://json#5)   | `Option<String>`        | Mars token denom        |

</CH.Section>

<img src={IncentivesUpdateConfigUrl} />

## QueryMsg

### `config`

Get contract config.

<CH.Section>
<CH.Code>

```json json
{
    "config": {}
}
```

```rust incentives.rs focus=1:5,14
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(Config)]
    Config {},
    #[returns(AssetIncentiveResponse)]
    AssetIncentive {
        denom: String,
    },
    #[returns(Uint128)]
    UserUnclaimedRewards {
        user: String,
    },
}
```

```rust contract.rs focus=1:4,11:12,14:17
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query_config(deps)?),
        QueryMsg::AssetIncentive {
            denom,
        } => to_binary(&query_asset_incentive(deps, denom)?),
        QueryMsg::UserUnclaimedRewards {
            user,
        } => to_binary(&query_user_unclaimed_rewards(deps, env, user)?),
    }
}

pub fn query_config(deps: Deps) -> StdResult<Config> {
    let config = CONFIG.load(deps.storage)?;
    Ok(config)
}
```

</CH.Code>
</CH.Section>

#### `Config` (response)

<CH.Section>
<CH.Code>

```json json
{
    "owner": "...",
    "address_provider": "...",
    "mars_denom": "..."
}
```

```rust incentives.rs
#[cw_serde]
pub struct Config {
    pub owner: Addr,
    pub address_provider: Addr,
    pub mars_denom: String,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`owner`](focus://json#2)   | `Addr`        | Contract owner        |
| [`address_provider`](focus://json#3)   | `Addr`        | Address provider        |
| [`mars_denom`](focus://json#4)   | `String`        | Mars Token Denom        |


</CH.Section>


### `asset_incentive`

Get info about asset incentive for a given denom.

<CH.Section>
<CH.Code>

```json json
{
    "asset_incentive": {
        "denom": "..."
    }
}
```

```rust incentives.rs focus=1:3,6:9,14
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(Config)]
    Config {},
    #[returns(AssetIncentiveResponse)]
    AssetIncentive {
        denom: String,
    },
    #[returns(Uint128)]
    UserUnclaimedRewards {
        user: String,
    },
}
```

```rust contract.rs focus=1:3,5:7,11:12,14:19
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query_config(deps)?),
        QueryMsg::AssetIncentive {
            denom,
        } => to_binary(&query_asset_incentive(deps, denom)?),
        QueryMsg::UserUnclaimedRewards {
            user,
        } => to_binary(&query_user_unclaimed_rewards(deps, env, user)?),
    }
}

pub fn query_asset_incentive(deps: Deps, denom: String) -> StdResult<AssetIncentiveResponse> {
    let option_asset_incentive = ASSET_INCENTIVES.may_load(deps.storage, &denom)?;
    Ok(AssetIncentiveResponse {
        asset_incentive: option_asset_incentive,
    })
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`denom`](focus://json#3)   | `String`        | Denom of the asset        |

</CH.Section>

#### `AssetIncentiveResponse`

<CH.Section>
<CH.Code>

```json json
{
    "emission_per_second": 123, 
    "index: 0.123", 
    "last_updated"": 123
}
```

```rust incentives.rs
#[cw_serde]
pub struct AssetIncentiveResponse {
    pub asset_incentive: Option<AssetIncentive>,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| `asset_incentive`   | [`Option<AssetIncentive>`](#assetincentive)        | Existing asset incentive for a given address. Will return None if it doesn't exist        |

</CH.Section>

#### `AssetIncentive`

<CH.Section>
<CH.Code>

```json json
{
    "emission_per_second": 123, 
    "index: 0.123", 
    "last_updated"": 123
}
```

```rust incentives.rs
#[cw_serde]
pub struct AssetIncentive {
    pub emission_per_second: Uint128,
    pub index: Decimal,
    pub last_updated: u64,
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`emission_per_second`](focus://json#2)   |  `Uint128`       | How much MARS per second is emitted to be then distributed to all Red Bank depositors        |
| [`index`](focus://json#3)   | `Decimal`        | Total MARS assigned for distribution since the start of the incentive        |
| [`last_updated`](focus://json#4)   | `u64`        | Last time (in seconds) index was updated        |


</CH.Section>


### `user_unclaimed_rewards`

Get user current unclaimed rewards.

<CH.Section>
<CH.Code>

```json json
{
    "user_unclaimed_rewards": {
        "user": "mars..."
    }
}
```

```rust incentives.rs focus=1:3,10:14
#[cw_serde]
#[derive(QueryResponses)]
pub enum QueryMsg {
    #[returns(Config)]
    Config {},
    #[returns(AssetIncentiveResponse)]
    AssetIncentive {
        denom: String,
    },
    #[returns(Uint128)]
    UserUnclaimedRewards {
        user: String,
    },
}
```

```rust contract.rs focus=1:3,8:12,14:21
#[cfg_attr(not(feature = "library"), entry_point)]
pub fn query(deps: Deps, env: Env, msg: QueryMsg) -> StdResult<Binary> {
    match msg {
        QueryMsg::Config {} => to_binary(&query_config(deps)?),
        QueryMsg::AssetIncentive {
            denom,
        } => to_binary(&query_asset_incentive(deps, denom)?),
        QueryMsg::UserUnclaimedRewards {
            user,
        } => to_binary(&query_user_unclaimed_rewards(deps, env, user)?),
    }
}

pub fn query_user_unclaimed_rewards(deps: Deps, env: Env, user: String) -> StdResult<Uint128> {
    let red_bank_addr = query_red_bank_address(deps)?;
    let user_addr = deps.api.addr_validate(&user)?;
    let (unclaimed_rewards, _) =
        compute_user_unclaimed_rewards(deps, &env.block, &red_bank_addr, &user_addr)?;

    Ok(unclaimed_rewards)
}
```

</CH.Code>

| **Params**      | **Type** | **Description** |
| ----------- | ----------- | ----------- |
| [`user`](focus://json#3)   | `String`        | User address        |

</CH.Section>

Returns `Uint128`
